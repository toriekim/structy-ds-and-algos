// PARENTHETICAL POSSIBILITIES
// -----------------------------------------------------------------
// Write a function, parentheticalPossibilities, that takes in a
// string as an argument. The function should return an array
// containing all of the strings that could be generated by
// expanding all parentheses of the string into its possibilities.

// For example, the possibilities for 'x(mn)yz' are 'xmyz', 'xnyz'.

// Example:
// parentheticalPossibilities('x(mn)yz'); // -> [ 'xmyz', 'xnyz' ]

const parentheticalPossibilities = (s) => {
  // Base case: If s is empty, there are no possibilities, return array with empty string
  if (s === '') return [''];

  // Get the next character option(s) with helper function
  const { options, remaining } = getOptions(s);
  // Get all possibilities of remaining string
  const suffixes = parentheticalPossibilities(remaining);
  // Initialize an empty array to hold all possibible strings
  const allPossibilities = [];

  // For each of the character option(s), add it to the beginning of each suffix possibility from recursive call
  for (let char of options) {
    for (let suffix of suffixes) {
      // Add the complete possibility string to the results array
      allPossibilities.push(char + suffix);
    }
  }

  return allPossibilities;
};

// Helper function that returns the character options and remaining string
const getOptions = (s) => {
  // If the first character is an opening parenthesis, get all the chars within the parentheses pair
  if (s[0] === '(') {
    // .indexOf() will return index of the first instance
    const endIdx = s.indexOf(')');
    const options = s.slice(1, endIdx).split('');
    // Get the remaining string after the parenthese pair
    const remaining = s.slice(endIdx + 1);
    // Return the character options and the remaining string
    return { options, remaining };
  } else {
    // Otherwise, the next character option is the first character
    return { options: [s[0]], remaining: s.slice(1) };
  }
};

// n = length of the string
// m = length of largest parenthetical group
// Time: ~O(m^n)
// Space: ~O(m^n)

export default { parentheticalPossibilities, getOptions };
